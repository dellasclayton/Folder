/**
 * Character Cache System
 * Provides instant access to characters and voices with local cache
 * Uses WebSocket-based database operations via db.js
 */

import * as db from './db.js'

class CharacterCache {
  constructor() {
    // In-memory storage
    this.characters = new Map()  // id -> character object
    this.voices = new Map()      // voice name -> voice object

    // State tracking
    this.isInitialized = false
    this.lastSync = null
    this.isLoading = false

    // Event handlers for cache updates
    this.eventHandlers = new Map()
  }

  /**
   * Initialize cache by loading all data from database
   * @returns {Promise<{characters: Array, voices: Array}>}
   */
  async initialize() {
    if (this.isInitialized) {
      console.log('Cache already initialized')
      return this.getAll()
    }

    this.isLoading = true
    console.log('Initializing character cache...')

    try {
      // Load characters and voices in parallel
      const [characters, voices] = await Promise.all([
        db.getCharacters(),
        db.getVoices(),
      ])

      // Populate cache
      const charArray = characters || []
      const voiceArray = voices || []

      charArray.forEach(char => this.characters.set(char.id, char))
      voiceArray.forEach(voice => this.voices.set(voice.voice, voice))

      this.isInitialized = true
      this.lastSync = Date.now()
      this.isLoading = false

      console.log(`Cache initialized: ${charArray.length} characters, ${voiceArray.length} voices`)

      // Emit initialization event
      this.emit('cache:initialized', { characters: charArray, voices: voiceArray })

      return this.getAll()

    } catch (error) {
      this.isLoading = false
      console.error('CharacterCache.initialize error:', error)
      throw error
    }
  }

  /**
   * Get all cached data
   * @returns {{characters: Array, voices: Array}}
   */
  getAll() {
    return {
      characters: Array.from(this.characters.values()),
      voices: Array.from(this.voices.values()),
    }
  }

  /**
   * Get a specific character by ID (instant, from cache)
   * @param {string} id - Character ID
   * @returns {Object|null}
   */
  getCharacter(id) {
    return this.characters.get(id) || null
  }

  /**
   * Get all characters (instant, from cache)
   * @returns {Array}
   */
  getAllCharacters() {
    return Array.from(this.characters.values())
  }

  /**
   * Get a specific voice by name (instant, from cache)
   * @param {string} voiceName - Voice name
   * @returns {Object|null}
   */
  getVoice(voiceName) {
    return this.voices.get(voiceName) || null
  }

  /**
   * Get all voices (instant, from cache)
   * @returns {Array}
   */
  getAllVoices() {
    return Array.from(this.voices.values())
  }

  /**
   * Create a new character (optimistic update + database sync)
   * @param {Object} characterData - Character data (without ID - generated by backend)
   * @returns {Promise<Object>} Created character with generated ID
   */
  async createCharacter(characterData) {
    console.log('Creating character:', characterData.name)

    try {
      // Create in database (backend generates ID)
      const data = await db.createCharacter(characterData)

      // Add to cache
      this.characters.set(data.id, data)

      console.log('Character created:', data.id)

      // Emit event
      this.emit('character:created', data)

      return data

    } catch (error) {
      console.error('CharacterCache.createCharacter error:', error)
      throw error
    }
  }

  /**
   * Update an existing character (optimistic update + database sync)
   * @param {string} id - Character ID
   * @param {Object} updates - Fields to update
   * @returns {Promise<Object>} Updated character
   */
  async updateCharacter(id, updates) {
    console.log('Updating character:', id)

    // Store original for rollback
    const original = this.characters.get(id)
    if (!original) {
      throw new Error(`Character not found: ${id}`)
    }

    // Optimistic update (update cache immediately)
    const optimistic = { ...original, ...updates }
    this.characters.set(id, optimistic)

    // Emit optimistic update event
    this.emit('character:updated', optimistic)

    try {
      // Sync to database
      const data = await db.updateCharacter(id, updates)

      // Update cache with server response (has timestamps, etc.)
      this.characters.set(data.id, data)

      console.log('Character updated:', data.id)

      // Emit confirmed update event
      this.emit('character:updated:confirmed', data)

      return data

    } catch (error) {
      // Rollback on error
      console.error('Update failed, rolling back:', error)
      this.characters.set(id, original)
      this.emit('character:updated', original)

      throw error
    }
  }

  /**
   * Set a character active state (optimistic update + database sync)
   * @param {string} id - Character ID
   * @param {boolean} isActive - Active state
   * @returns {Promise<Object>} Updated character
   */
  async setCharacterActive(id, isActive) {
    console.log('Setting character active:', id, isActive)

    const original = this.characters.get(id)
    if (!original) {
      throw new Error(`Character not found: ${id}`)
    }

    const optimistic = { ...original, is_active: isActive }
    this.characters.set(id, optimistic)
    this.emit('character:updated', optimistic)

    try {
      const data = await db.setCharacterActive(id, isActive)
      this.characters.set(data.id, data)
      this.emit('character:updated:confirmed', data)
      return data

    } catch (error) {
      console.error('Set active failed, rolling back:', error)
      this.characters.set(id, original)
      this.emit('character:updated', original)
      throw error
    }
  }

  /**
   * Delete a character (optimistic update + database sync)
   * @param {string} id - Character ID
   * @returns {Promise<void>}
   */
  async deleteCharacter(id) {
    console.log('Deleting character:', id)

    // Store original for rollback
    const original = this.characters.get(id)
    if (!original) {
      throw new Error(`Character not found: ${id}`)
    }

    // Optimistic delete (remove from cache immediately)
    this.characters.delete(id)

    // Emit optimistic delete event
    this.emit('character:deleted', { id, character: original })

    try {
      // Sync to database
      await db.deleteCharacter(id)

      console.log('Character deleted:', id)

      // Emit confirmed delete event
      this.emit('character:deleted:confirmed', { id })

    } catch (error) {
      // Rollback on error
      console.error('Delete failed, rolling back:', error)
      this.characters.set(id, original)
      this.emit('character:created', original) // Re-add to UI

      throw error
    }
  }

  /**
   * Create a new voice
   * @param {Object} voiceData - Voice data
   * @returns {Promise<Object>} Created voice
   */
  async createVoice(voiceData) {
    console.log('Creating voice:', voiceData.voice)

    try {
      // Create in database
      const data = await db.createVoice(voiceData)

      // Add to cache
      this.voices.set(data.voice, data)

      console.log('Voice created:', data.voice)

      // Emit event
      this.emit('voice:created', data)

      return data

    } catch (error) {
      console.error('CharacterCache.createVoice error:', error)
      throw error
    }
  }

  /**
   * Update an existing voice
   * @param {string} voiceName - Voice name
   * @param {Object} updates - Fields to update
   * @returns {Promise<Object>} Updated voice
   */
  async updateVoice(voiceName, updates) {
    console.log('Updating voice:', voiceName)

    // Store original for rollback
    const original = this.voices.get(voiceName)
    if (!original) {
      throw new Error(`Voice not found: ${voiceName}`)
    }

    const newVoiceName = typeof updates?.new_voice === 'string' ? updates.new_voice.trim() : null
    const isRename = newVoiceName && newVoiceName !== voiceName

    const updateCharactersForVoice = (fromVoice, toVoice) => {
      if (!fromVoice || !toVoice || fromVoice === toVoice) return
      this.characters.forEach((character, id) => {
        if (character.voice === fromVoice) {
          const updated = { ...character, voice: toVoice }
          this.characters.set(id, updated)
          this.emit('character:updated', updated)
        }
      })
    }

    // Optimistic update
    const optimistic = { ...original, ...updates }
    if (isRename) {
      optimistic.voice = newVoiceName
      this.voices.delete(voiceName)
      this.voices.set(newVoiceName, optimistic)
      updateCharactersForVoice(voiceName, newVoiceName)
    } else {
      this.voices.set(voiceName, optimistic)
    }

    this.emit('voice:updated', optimistic)

    try {
      // Sync to database
      const data = await db.updateVoice(voiceName, updates)

      // Update cache with server response
      if (data.voice !== voiceName) {
        this.voices.delete(voiceName)
      }
      this.voices.delete(newVoiceName)
      this.voices.set(data.voice, data)
      updateCharactersForVoice(voiceName, data.voice)

      console.log('Voice updated:', data.voice)
      this.emit('voice:updated:confirmed', data)

      return data

    } catch (error) {
      // Rollback
      if (isRename) {
        this.voices.delete(newVoiceName)
        updateCharactersForVoice(newVoiceName, voiceName)
      }
      this.voices.set(voiceName, original)
      this.emit('voice:updated', original)

      throw error
    }
  }

  /**
   * Delete a voice
   * @param {string} voiceName - Voice name
   * @returns {Promise<void>}
   */
  async deleteVoice(voiceName) {
    console.log('Deleting voice:', voiceName)

    const original = this.voices.get(voiceName)
    if (!original) {
      throw new Error(`Voice not found: ${voiceName}`)
    }

    const affectedCharacters = []

    const clearCharactersForVoice = () => {
      this.characters.forEach((character, id) => {
        if (character.voice === voiceName) {
          affectedCharacters.push({ id, character })
          const updated = { ...character, voice: '' }
          this.characters.set(id, updated)
          this.emit('character:updated', updated)
        }
      })
    }

    // Optimistic delete
    this.voices.delete(voiceName)
    this.emit('voice:deleted', { voice: voiceName, data: original })
    clearCharactersForVoice()

    try {
      await db.deleteVoice(voiceName)

      console.log('Voice deleted:', voiceName)
      this.emit('voice:deleted:confirmed', { voice: voiceName })

    } catch (error) {
      // Rollback
      this.voices.set(voiceName, original)
      affectedCharacters.forEach(({ id, character }) => {
        this.characters.set(id, character)
        this.emit('character:updated', character)
      })
      this.emit('voice:created', original)

      throw error
    }
  }

  /**
   * Refresh cache from database
   * @returns {Promise<{characters: Array, voices: Array}>}
   */
  async refresh() {
    console.log('Refreshing cache from database...')

    try {
      const [characters, voices] = await Promise.all([
        db.getCharacters(),
        db.getVoices(),
      ])

      // Clear and repopulate
      this.characters.clear()
      this.voices.clear()

      const charArray = characters || []
      const voiceArray = voices || []

      charArray.forEach(char => this.characters.set(char.id, char))
      voiceArray.forEach(voice => this.voices.set(voice.voice, voice))

      this.lastSync = Date.now()

      console.log(`Cache refreshed: ${charArray.length} characters, ${voiceArray.length} voices`)

      this.emit('cache:refreshed', { characters: charArray, voices: voiceArray })

      return this.getAll()

    } catch (error) {
      console.error('Cache refresh failed:', error)
      throw error
    }
  }

  /**
   * Register an event handler
   * @param {string} eventName - Event name
   * @param {Function} handler - Callback function
   */
  on(eventName, handler) {
    if (!this.eventHandlers.has(eventName)) {
      this.eventHandlers.set(eventName, [])
    }
    this.eventHandlers.get(eventName).push(handler)
  }

  /**
   * Unregister an event handler
   * @param {string} eventName - Event name
   * @param {Function} handler - Callback function
   */
  off(eventName, handler) {
    if (!this.eventHandlers.has(eventName)) return

    const handlers = this.eventHandlers.get(eventName)
    const index = handlers.indexOf(handler)
    if (index > -1) {
      handlers.splice(index, 1)
    }
  }

  /**
   * Emit an event to all registered handlers
   * @param {string} eventName - Event name
   * @param {*} data - Event data
   */
  emit(eventName, data) {
    const handlers = this.eventHandlers.get(eventName) || []
    handlers.forEach(handler => {
      try {
        handler(data)
      } catch (error) {
        console.error(`Error in event handler for ${eventName}:`, error)
      }
    })
  }

  /**
   * Clear the cache (useful for logout or testing)
   */
  clear() {
    this.characters.clear()
    this.voices.clear()
    this.isInitialized = false
    this.lastSync = null
    console.log('Cache cleared')
  }

  /**
   * Get cache statistics
   * @returns {Object} Cache stats
   */
  getStats() {
    return {
      characters: this.characters.size,
      voices: this.voices.size,
      isInitialized: this.isInitialized,
      lastSync: this.lastSync,
    }
  }
}

// Export singleton instance
export const characterCache = new CharacterCache()

// Export class for testing
export { CharacterCache }
